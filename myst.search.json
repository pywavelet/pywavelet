{"version":"1","records":[{"hierarchy":{"lvl1":"API"},"type":"lvl1","url":"/api","position":0},{"hierarchy":{"lvl1":"API"},"content":"The main functionality of pywavelet is to help transform/inverse transform\ndata from the time/frequency domains to the WDM-wavelet domain.","type":"content","url":"/api","position":1},{"hierarchy":{"lvl1":"API","lvl2":"Transform Functions"},"type":"lvl2","url":"/api#transform-functions","position":2},{"hierarchy":{"lvl1":"API","lvl2":"Transform Functions"},"content":"pywavelet.transforms.from_time_to_wavelet\n\npywavelet.transforms.from_freq_to_wavelet\n\npywavelet.transforms.from_wavelet_to_freq\n\npywavelet.transforms.from_wavelet_to_time","type":"content","url":"/api#transform-functions","position":3},{"hierarchy":{"lvl1":"API","lvl2":"Types"},"type":"lvl2","url":"/api#types","position":4},{"hierarchy":{"lvl1":"API","lvl2":"Types"},"content":"pywavelet.types.TimeSeries\n\npywavelet.types.FrequencySeries\n\npywavelet.types.Wavelet","type":"content","url":"/api#types","position":5},{"hierarchy":{"lvl1":"Accuracy checks"},"type":"lvl1","url":"/examples/accuracy","position":0},{"hierarchy":{"lvl1":"Accuracy checks"},"content":"","type":"content","url":"/examples/accuracy","position":1},{"hierarchy":{"lvl1":"Accuracy checks"},"type":"lvl1","url":"/examples/accuracy#accuracy-checks","position":2},{"hierarchy":{"lvl1":"Accuracy checks"},"content":"\n\n!echo \"GPU info\"\n!nvidia-smi\n!nvidia-smi -L\n! echo \"CPU INFO\"\n!lscpu |grep 'Model name'\n!lscpu | grep 'Core(s) per socket:'\n!lscpu | grep 'Thread(s) per core'\n!free -h --si | awk  '/Mem:/{print $2}'\n\n\n\n! pip install pywavelet -q\n\n\n\n","type":"content","url":"/examples/accuracy#accuracy-checks","position":3},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Monochromatic Wavelet check"},"type":"lvl2","url":"/examples/accuracy#monochromatic-wavelet-check","position":4},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Monochromatic Wavelet check"},"content":"\n\nfrom pywavelet.types import Wavelet, FrequencySeries, TimeSeries\nfrom pywavelet.types.wavelet_bins import compute_bins\nfrom dataclasses import dataclass\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import Normalize, LogNorm\n\n\n@dataclass\nclass Params:\n    f0: float = 20\n    dt: float = 0.0125\n    A: float = 1\n    Nt: int = 32\n    Nf: int = 32\n\n    @property\n    def list(self):\n        return [self.f0, self.dt, self.A, self.Nt, self.Nf]\n\n    def __repr__(self):\n        return f\"f0={self.f0}, A={self.A}\"\n\n\ndef monochromatic_wnm(\n    f0: float,\n    dt: float,\n    A: float,\n    Nt: int,\n    Nf: int,\n) -> Wavelet:\n    T = Nt * Nf * dt\n    N = Nt * Nf\n    t_bins, f_bins = compute_bins(Nf, Nt, T)\n    wnm = np.zeros((Nt, Nf))\n    m0 = int(f0 * N * dt)\n    f0_bin_idx = int(2 * m0 / Nt)\n    odd_t_indices = np.arange(Nt) % 2 != 0\n    wnm[odd_t_indices, f0_bin_idx] = A * np.sqrt(2 * Nf)\n    return Wavelet(wnm.T, t_bins, f_bins)\n\n\ndef monochromatic_timeseries(\n    f0: float,\n    dt: float,\n    A: float,\n    Nt: int,\n    Nf: int,\n) -> TimeSeries:\n    ND = Nt * Nf\n    t = np.arange(0, ND) * dt\n    y = A * np.sin(2 * np.pi * f0 * t)\n    return TimeSeries(data=y, time=t)\n\n\ndefault_params = Params()\n\n\ndef plot_comparison(params):\n\n    true_wdm = monochromatic_wnm(*params.list)\n    true_tdm = monochromatic_timeseries(*params.list)\n    fdm = true_tdm.to_frequencyseries()\n    wdm = fdm.to_wavelet(Nt=params.Nt, Nf=params.Nf)\n    mse = np.mean((wdm.data - true_wdm.data) ** 2)\n\n    fig, ax = plt.subplots(1, 2, figsize=(7, 3.5), sharex=True, sharey=True)\n    norm = Normalize(vmin=0, vmax=wdm.data.max())\n    kwargs = dict(absolute=True, norm=norm, cmap=\"Blues\", show_colorbar=False)\n    true_wdm.plot(ax=ax[0], **kwargs, label=\"Analytical\")\n    wdm.plot(ax=ax[1], **kwargs, label=\"FD-->WDM\")\n    ax[1].set_ylabel(\"\")\n    # set common colorbar using norm\n    sm = plt.cm.ScalarMappable(cmap=\"Blues\", norm=norm)\n    sm.set_array([])\n    fig.colorbar(\n        sm, ax=ax, orientation=\"vertical\", label=\"Absolute WDM amplitude\"\n    )\n    fig.suptitle(f\"MSE={mse:.2e}\")\n    # tight layout whle accommodating suptitle + colorbar\n    fig.tight_layout(rect=[0, 0, 0.8, 0.95])\n    plt.show()\n\n\nplot_comparison(Params(f0=20, A=1))\nplot_comparison(Params(f0=20.1, A=1))\n\n\n\n\n\nNamp, Nfreq = 10, 20\namplitudes = np.linspace(1, 10, Namp)\nf0s = np.linspace(2, 38, Nfreq)\n\nerrors = np.zeros((Namp, Nfreq))\nfor i, A in enumerate(amplitudes):\n    for j, f0 in enumerate(f0s):\n        p = Params(f0=f0, A=A)\n        true = monochromatic_wnm(*p.list)\n\n        wdm = (\n            monochromatic_timeseries(*p.list)\n            .to_frequencyseries()\n            .to_wavelet(Nt=p.Nt, Nf=p.Nf)\n        )\n        errors[i, j] = np.mean((wdm.data - true.data) ** 2)\n\nfig, ax = plt.subplots(1, 1, figsize=(3.5, 3.5))\n# plot grid of errors as a function of amplitude and frequency\nc = ax.pcolormesh(f0s, amplitudes, errors)\n\nax.set_xlabel(\"f0\")\nax.set_ylabel(\"Amplitude\")\nax.set_title(\"MSE\")\nfig.colorbar(c, ax=ax, label=\"MSE\")\n\n\n\nNamp, Nfreq = 10, 20\namplitudes = np.linspace(1, 10, Namp)\ndefault_wdm = monochromatic_wnm(*default_params.list)\n# arrange f0s such that the bin is  an integer multiple of Delta_F\nf0s = default_wdm.freq[2::2]\n# get midpoints of f0s\n\nNfreq = len(f0s)\n\n\nerrors = np.zeros((Namp, Nfreq))\nfor i, A in enumerate(amplitudes):\n    for j, f0 in enumerate(f0s):\n        p = Params(f0=f0, A=A)\n        true = monochromatic_wnm(*p.list)\n\n        wdm = (\n            monochromatic_timeseries(*p.list)\n            .to_frequencyseries()\n            .to_wavelet(Nt=p.Nt, Nf=p.Nf)\n        )\n        errors[i, j] = np.mean((wdm.data - true.data) ** 2)\n\nfig, ax = plt.subplots(1, 1, figsize=(3.5, 3.5))\n# plot grid of errors as a function of amplitude and frequency\nc = ax.pcolormesh(f0s, amplitudes, errors, norm=LogNorm())\n\nax.set_xlabel(\"f0\")\nax.set_ylabel(\"Amplitude\")\nax.set_title(\"MSE\")\nfig.colorbar(c, ax=ax, label=\"MSE\")\n\n\n\n","type":"content","url":"/examples/accuracy#monochromatic-wavelet-check","position":5},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Parseval’s Theorem Test (Energy Conservation)"},"type":"lvl2","url":"/examples/accuracy#parsevals-theorem-test-energy-conservation","position":6},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Parseval’s Theorem Test (Energy Conservation)"},"content":"The total energy of a signal is the same whether calculated directly in the time domain or indirectly from its Fourier transform in the frequency domain. This means no information is lost during the transformation between time and frequency representations.\n\nLets see if this holds true for the wavelet transform. We will use a simple sinusoidal signal and check if the energy in the time domain matches the energy in the frequency domain.\n\nts = monochromatic_timeseries(\n    f0=20,\n    dt=0.0125,\n    A=1,\n    Nt=32,\n    Nf=32,\n)\nwdm = ts.to_wavelet(Nt=32)\n\n\n# Calculate energy in time domain\nenergy_time = np.abs(ts.data) ** 2\nenergy_wavelet = np.abs(wdm.data) ** 2\n\nif np.isclose(\n    np.sum(energy_time), np.sum(energy_wavelet), rtol=1e-5, atol=1e-5\n):\n    print(\"Parseval's theorem holds: Energy is conserved.\")\nelse:\n    print(\"Parseval's theorem does not hold: Energy is not conserved.\")\n    print(f\"Time domain energy: {np.sum(energy_time)}\")\n    print(f\"Wavelet domain energy: {np.sum(energy_wavelet)}\")\n\n\n\n","type":"content","url":"/examples/accuracy#parsevals-theorem-test-energy-conservation","position":7},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Roundtrip"},"type":"lvl2","url":"/examples/accuracy#roundtrip","position":8},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Roundtrip"},"content":"\n\nfrom scipy.signal import chirp\nimport numpy as np\nfrom typing import List\nimport matplotlib.pyplot as plt\nimport os\n\nfrom pywavelet.types import TimeSeries, FrequencySeries\n\nPLOT_DIR = f\"backend_plots\"\nos.makedirs(PLOT_DIR, exist_ok=True)\n\n\ndef generate_chirp_time_domain_signal(\n    t: np.ndarray, freq_range: List[float]\n) -> TimeSeries:\n    fs = 1 / (t[1] - t[0])\n    nyquist = fs / 2\n    fmax = max(freq_range)\n    assert (\n        fmax < nyquist\n    ), f\"f_max [{fmax:.2f} Hz] must be less than f_nyquist [{nyquist:2f} Hz].\"\n\n    y = chirp(\n        t, f0=freq_range[0], f1=freq_range[1], t1=t[-1], method=\"hyperbolic\"\n    )\n    return TimeSeries(data=y, time=t)\n\n\ndef plot_residuals(ax, residuals):\n    ax.hist(residuals, bins=100)\n    # add textbox of mean and std\n    mean = residuals.mean()\n    std = residuals.std()\n    textstr = f\"$\\mu={mean:.1E}$\\n$\\sigma={std:.1E}$\"\n    props = dict(boxstyle=\"round\", facecolor=\"wheat\", alpha=0.5)\n    ax.text(\n        0.05,\n        0.95,\n        textstr,\n        transform=ax.transAxes,\n        fontsize=14,\n        verticalalignment=\"top\",\n        bbox=props,\n    )\n    ax.set_xlabel(\"Residuals\")\n    ax.set_ylabel(\"Count\")\n    ax.ticklabel_format(axis=\"x\", style=\"sci\", scilimits=(0, 0))\n    return ax\n\n\ndef plot(h_freq, h_reconstructed, h_wavelet, title=None):\n    fig, axes = plt.subplots(1, 3, figsize=(18, 4))\n    _ = h_freq.plot_periodogram(ax=axes[0], color=\"black\", label=\"Original\")\n    _ = h_reconstructed.plot_periodogram(\n        ax=axes[0], ls=\"--\", color=\"red\", label=\"Reconstructed\"\n    )\n    _ = h_wavelet.plot(ax=axes[1], absolute=True, cmap=\"Reds\")\n    _ = plot_residuals(axes[2], h_freq.data - h_reconstructed.data)\n    axes[0].legend()\n    axes[0].set_title(\"Orig[black] vs Reconstructed[red]\")\n    axes[1].set_title(\"Wavelet Domain\")\n    axes[2].set_title(\"Residuals\")\n    if title is not None:\n        fig.suptitle(title)\n    plt.tight_layout()\n    # remove whitespace in 'title'\n    fname = title.replace(\" \", \"_\") if title else \"roundtrip\"\n    fig.savefig(f\"{PLOT_DIR}/{fname}.png\", dpi=300, bbox_inches=\"tight\")\n    plt.close(fig)\n\n\n# Sizes\ndt = 1 / 512\nNt, Nf = 2**6, 2**6\nmult = 16\nfreq_range = (10, 0.2 * (1 / dt))\nND = Nt * Nf\nts = np.arange(0, ND) * dt\nh_time = generate_chirp_time_domain_signal(ts, freq_range)\nh_freq = h_time.to_frequencyseries()\n\n\n\n","type":"content","url":"/examples/accuracy#roundtrip","position":9},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"Numpy","lvl2":"Roundtrip"},"type":"lvl3","url":"/examples/accuracy#numpy","position":10},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"Numpy","lvl2":"Roundtrip"},"content":"\n\nfrom pywavelet.transforms.numpy import (\n    from_freq_to_wavelet,\n    from_wavelet_to_freq,\n)\n\nh_wavelet = from_freq_to_wavelet(h_freq, Nf=Nf, Nt=Nt)\nh_reconstructed = from_wavelet_to_freq(h_wavelet, dt=dt)\nplot(h_freq, h_reconstructed, h_wavelet, title=\"NumPy Roundtrip\")\n\n\n\n","type":"content","url":"/examples/accuracy#numpy","position":11},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"JAX","lvl2":"Roundtrip"},"type":"lvl3","url":"/examples/accuracy#jax","position":12},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"JAX","lvl2":"Roundtrip"},"content":"\n\nimport jax\n\njax.config.update(\"jax_enable_x64\", True)\n\nfrom pywavelet.transforms.jax import (\n    from_freq_to_wavelet as jax_from_freq_to_wavelet,\n)\nfrom pywavelet.transforms.jax import (\n    from_wavelet_to_freq as jax_from_wavelet_to_freq,\n)\n\njax_h_wavelet = jax_from_freq_to_wavelet(h_freq, Nf=Nf, Nt=Nt)\njax_h_reconstructed = jax_from_wavelet_to_freq(h_wavelet, dt=dt)\nplot(h_freq, jax_h_reconstructed, jax_h_wavelet, title=\"JAX Roundtrip\")\n\n\n\n\n\n","type":"content","url":"/examples/accuracy#jax","position":13},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"CuPy","lvl2":"Roundtrip"},"type":"lvl3","url":"/examples/accuracy#cupy","position":14},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"CuPy","lvl2":"Roundtrip"},"content":"\n\nfrom pywavelet.backend import cuda_is_available\n\nif not cuda_is_available():\n    print(\n        \"CuPy backend is not available. Please install CuPy with CUDA support.\"\n    )\nelse:\n    from pywavelet.transforms.cupy import (\n        from_freq_to_wavelet as cp_from_freq_to_wavelet,\n    )\n    from pywavelet.transforms.cupy import (\n        from_wavelet_to_freq as cp_from_wavelet_to_freq,\n    )\n\n    cp_h_wavelet = cp_from_freq_to_wavelet(h_freq, Nf=Nf, Nt=Nt)\n    cp_h_reconstructed = cp_from_wavelet_to_freq(h_wavelet, dt=dt)\n    plot(h_freq, cp_h_reconstructed, cp_h_wavelet, title=\"CuPy Roundtrip\")\n\n\n\n","type":"content","url":"/examples/accuracy#cupy","position":15},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"Results","lvl2":"Roundtrip"},"type":"lvl3","url":"/examples/accuracy#results","position":16},{"hierarchy":{"lvl1":"Accuracy checks","lvl3":"Results","lvl2":"Roundtrip"},"content":"Backend\n\nRoundtrip Plot\n\nNumPy\n\n\n\nJAX\n\n\n\nCuPy\n\n(not available in docs build)\n\n","type":"content","url":"/examples/accuracy#results","position":17},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Noise robustness"},"type":"lvl2","url":"/examples/accuracy#noise-robustness","position":18},{"hierarchy":{"lvl1":"Accuracy checks","lvl2":"Noise robustness"},"content":"\n\nimport numpy as np\nfrom pywavelet.types import TimeSeries, FrequencySeries\nfrom time import process_time\n\nnp.random.seed(42)  # For reproducibility\n\n\ndef generate_white_noise(\n    N: int = 2**20, scale: float = 1.0\n) -> FrequencySeries:\n    \"\"\"Generate white noise time series.\"\"\"\n    noise = np.random.normal(0, scale, N)\n    return TimeSeries(data=noise, time=np.arange(N)).to_frequencyseries()\n\n\ndatasets = [generate_white_noise() for _ in range(100)]\n\n\ndef get_residuals(datasets, forward_transform, inverse_transform, Nf=2**10):\n    mse = np.zeros((len(datasets), 2))\n    for i, h_freq in enumerate(datasets):\n        t0 = process_time()\n        h_wavelet = forward_transform(h_freq, Nf=Nf)\n        h_reconstructed = inverse_transform(h_wavelet, dt=h_time.dt)\n        mse[i, 0] = get_mse(h_freq, h_reconstructed)\n        mse[i, 1] = process_time() - t0\n\n    return mse[1:].T\n\n\ndef get_mse(f1, f2):\n    \"\"\"Calculate Mean Squared Error between two frequency series.\"\"\"\n    return float(np.mean((np.abs(f1.data - f2.data) ** 2)[1:-1]))\n\n\nnumpy_mses = get_residuals(\n    datasets, from_freq_to_wavelet, from_wavelet_to_freq\n)\n\njax_mses = get_residuals(\n    datasets, jax_from_freq_to_wavelet, jax_from_wavelet_to_freq\n)\n\n\ncp_mses = None\nif cuda_is_available():\n    from pywavelet.transforms.cupy import (\n        from_freq_to_wavelet as cp_from_freq_to_wavelet,\n    )\n    from pywavelet.transforms.cupy import (\n        from_wavelet_to_freq as cp_from_wavelet_to_freq,\n    )\n\n    cp_mses = get_residuals(\n        datasets, cp_from_freq_to_wavelet, cp_from_wavelet_to_freq\n    )\n\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nimport matplotlib.pyplot as plt\n\n# Set the desired RC parameters\nrc_params = {\n    \"xtick.direction\": \"in\",  # Mirrored ticks (in and out)\n    \"ytick.direction\": \"in\",\n    \"xtick.top\": True,  # Show ticks on the top spine\n    \"ytick.right\": True,  # Show ticks on the right spine\n    \"xtick.major.size\": 6,  # Length of major ticks\n    \"ytick.major.size\": 6,\n    \"xtick.minor.size\": 4,  # Length of minor ticks\n    \"ytick.minor.size\": 4,\n    \"xtick.major.pad\": 4,  # Padding between tick and label\n    \"ytick.major.pad\": 4,\n    \"xtick.minor.pad\": 4,\n    \"ytick.minor.pad\": 4,\n    \"font.size\": 14,  # Overall font size\n    \"axes.labelsize\": 16,  # Font size of axis labels\n    \"axes.titlesize\": 18,  # Font size of plot title\n    \"xtick.labelsize\": 12,  # Font size of x-axis tick labels\n    \"ytick.labelsize\": 12,  # Font size of y-axis tick labels\n    \"xtick.major.width\": 2,  # Thickness of major ticks\n    \"ytick.major.width\": 2,  # Thickness of major ticks\n    \"xtick.minor.width\": 1,  # Thickness of minor ticks\n    \"ytick.minor.width\": 1,  # Thickness of minor ticks\n    \"lines.linewidth\": 3,  # Default linewidth for lines in plots\n    \"patch.linewidth\": 4,  # Default linewidth for patches (e.g., rectangles, circles)\n    \"axes.linewidth\": 2,  # Default linewidth for the axes spines\n}\n\n# Apply the RC parameters globally\nplt.rcParams.update(rc_params)\n\nCOLORS = dict(teal=\"#17becf\", gray=\"#c9c9c9\", red=\"#d62728\")\n\n# Data setup\nMSE = [numpy_mses[0], jax_mses[0]] + (\n    [cp_mses[0]] if cp_mses is not None else jax_mses[0]\n)\nruntimes = [numpy_mses[1], jax_mses[1]] + (\n    [cp_mses[1]] if cp_mses is not None else jax_mses[1]\n)\n\nlabels = [\"NumPy\", \"JAX\"] + ([\"CuPy\"] if cp_mses is not None else [])\ncolors = [\"#d62728\", \"#17becf\"] + ([\"#c9c9c9\"] if cp_mses is not None else [])\npositions = np.arange(len(labels)) * 1.0  # Spaced positions\n\nfig, axes = plt.subplots(2, 1, figsize=(4, 5), sharex=True)\n\n\n# Plot helper\ndef make_boxplot(ax, data, title, ylabel):\n    for i, d in enumerate(data):\n        ax.boxplot(\n            d,\n            positions=[positions[i]],\n            widths=0.8,\n            patch_artist=True,\n            boxprops=dict(\n                facecolor=colors[i], alpha=0.4, color=colors[i], linewidth=0\n            ),\n            medianprops=dict(color=colors[i], linewidth=2.5),\n            whiskerprops=dict(color=colors[i], linewidth=2.5),\n            capprops=dict(color=colors[i], linewidth=2.5),\n            flierprops=dict(\n                marker=\"o\", color=colors[i], alpha=0.6, markersize=0\n            ),\n        )\n    # ax.set_title(title)\n    ax.set_ylabel(ylabel)\n    # ax.grid(axis=\"y\", linestyle=\"--\", alpha=0.4)\n\n\nmake_boxplot(axes[0], MSE, \"Mean Squared Errors (MSEs)\", \"MSE\")\nmake_boxplot(axes[1], runtimes, \"Runtimes\", \"Runtime [s]\")\n\naxes[1].set_xticks(positions)\naxes[1].set_xticklabels(labels)\n\n# remove whitespace between subplots\nplt.subplots_adjust(hspace=0)\n\n\n# plt.tight_layout()\nplt.savefig(\"mes.pdf\", dpi=300, bbox_inches=\"tight\")\nplt.show()\n\n","type":"content","url":"/examples/accuracy#noise-robustness","position":19},{"hierarchy":{"lvl1":"Example"},"type":"lvl1","url":"/examples/basic","position":0},{"hierarchy":{"lvl1":"Example"},"content":"","type":"content","url":"/examples/basic","position":1},{"hierarchy":{"lvl1":"Example"},"type":"lvl1","url":"/examples/basic#example","position":2},{"hierarchy":{"lvl1":"Example"},"content":"","type":"content","url":"/examples/basic#example","position":3},{"hierarchy":{"lvl1":"Example","lvl2":"Time to Wavelet"},"type":"lvl2","url":"/examples/basic#time-to-wavelet","position":4},{"hierarchy":{"lvl1":"Example","lvl2":"Time to Wavelet"},"content":"Let’s transform a time-domain signal (of length N), to the wavelet-domain (of shape N_t\\times N_f) and back to time-domain.\n\n! pip install pywavelet -q\n\n\n\nfrom scipy.signal import chirp\nimport numpy as np\nfrom typing import List\nimport matplotlib.pyplot as plt\n\nfrom pywavelet.types import TimeSeries\nfrom pywavelet.transforms import from_time_to_wavelet, from_wavelet_to_time\n\n\ndef generate_chirp_time_domain_signal(\n    t: np.ndarray, freq_range: List[float]\n) -> TimeSeries:\n    fs = 1 / (t[1] - t[0])\n    nyquist = fs / 2\n    fmax = max(freq_range)\n    assert (\n        fmax < nyquist\n    ), f\"f_max [{fmax:.2f} Hz] must be less than f_nyquist [{nyquist:2f} Hz].\"\n\n    y = chirp(\n        t, f0=freq_range[0], f1=freq_range[1], t1=t[-1], method=\"hyperbolic\"\n    )\n    return TimeSeries(data=y, time=t)\n\n\ndef plot_residuals(ax, residuals):\n    ax.hist(residuals, bins=100)\n    # add textbox of mean and std\n    mean = residuals.mean()\n    std = residuals.std()\n    textstr = f\"$\\mu={mean:.1E}$\\n$\\sigma={std:.1E}$\"\n    props = dict(boxstyle=\"round\", facecolor=\"wheat\", alpha=0.5)\n    ax.text(\n        0.05,\n        0.95,\n        textstr,\n        transform=ax.transAxes,\n        fontsize=14,\n        verticalalignment=\"top\",\n        bbox=props,\n    )\n    ax.set_xlabel(\"Residuals\")\n    ax.set_ylabel(\"Count\")\n    ax.ticklabel_format(axis=\"x\", style=\"sci\", scilimits=(0, 0))\n    return ax\n\n\n# Sizes\ndt = 1 / 512\nNt, Nf = 2**6, 2**6\nmult = 16\nfreq_range = (10, 0.2 * (1 / dt))\nND = Nt * Nf\n\n# time grid\nts = np.arange(0, ND) * dt\nh_time = generate_chirp_time_domain_signal(ts, freq_range)\n\n\n# transform to wavelet domain\nh_wavelet = from_time_to_wavelet(h_time, Nf=Nf, Nt=Nt, mult=mult)\n\n# transform back to time domain\nh_reconstructed = from_wavelet_to_time(h_wavelet, dt=h_time.dt, mult=mult)\n\n# Plots\nfig, axes = plt.subplots(1, 4, figsize=(18, 4))\n_ = h_time.plot_spectrogram(ax=axes[0])\n_ = h_wavelet.plot(ax=axes[1], absolute=True, cmap=\"Reds\")\n_ = h_reconstructed.plot_spectrogram(ax=axes[2])\n_ = plot_residuals(axes[3], h_time.data - h_reconstructed.data)\naxes[0].set_title(\"Original Time Domain\")\naxes[1].set_title(\"Wavelet Domain\")\naxes[2].set_title(\"Reconstructed Time Domain\")\naxes[3].set_title(\"Residuals\")\nfor ax in axes[0:3]:\n    ax.set_ylim(*freq_range)\nfig.savefig(\"roundtrip_time.png\")\nplt.close()\n\n\n\nProvide data as a TimeSeries/FrequencySeries object\n\nThese objects will ensure correct bins for time/frequency in the WDM-domain.","type":"content","url":"/examples/basic#time-to-wavelet","position":5},{"hierarchy":{"lvl1":"Example","lvl2":"Freq to Wavelet"},"type":"lvl2","url":"/examples/basic#freq-to-wavelet","position":6},{"hierarchy":{"lvl1":"Example","lvl2":"Freq to Wavelet"},"content":"This time, we use a sine-wave in the frequency domain.\n\nimport numpy as np\nfrom pywavelet.types import FrequencySeries\nfrom pywavelet.transforms import from_freq_to_wavelet, from_wavelet_to_freq\nimport matplotlib.pyplot as plt\n\nf0 = 20\ndt = 0.0125\nNt = 32\nNf = 256\nN = Nf * Nt\n\nfreq = np.fft.rfftfreq(N, dt)\nhf = np.zeros_like(freq, dtype=np.complex128)\nhf[np.argmin(np.abs(freq - f0))] = 1.0\n\n\nh_freq = FrequencySeries(data=hf, freq=freq)\nh_wavelet = from_freq_to_wavelet(h_freq, Nf=Nf, Nt=Nt)\nh_reconstructed = from_wavelet_to_freq(h_wavelet, dt=h_freq.dt)\n\n\nfig, axes = plt.subplots(1, 2, figsize=(9, 4))\n_ = h_freq.plot(ax=axes[0], label=\"Original\")\n_ = h_wavelet.plot(ax=axes[1], absolute=True, cmap=\"Reds\")\n_ = h_reconstructed.plot(ax=axes[0], ls=\":\", label=\"Reconstructed\")\naxes[1].set_ylim(f0 - 5, f0 + 5)\naxes[0].legend()\nfig.savefig(\"roundtrip_freq.png\")\nplt.close()\n\n\n\n","type":"content","url":"/examples/basic#freq-to-wavelet","position":7},{"hierarchy":{"lvl1":"EMRI, Galactic Binary, and MBH Transformation examples"},"type":"lvl1","url":"/examples/example-signals","position":0},{"hierarchy":{"lvl1":"EMRI, Galactic Binary, and MBH Transformation examples"},"content":"","type":"content","url":"/examples/example-signals","position":1},{"hierarchy":{"lvl1":"EMRI, Galactic Binary, and MBH Transformation examples"},"type":"lvl1","url":"/examples/example-signals#emri-galactic-binary-and-mbh-transformation-examples","position":2},{"hierarchy":{"lvl1":"EMRI, Galactic Binary, and MBH Transformation examples"},"content":"We generate the signals using the fastemriwaveforms, bbhx and gbbgpu packages.\nThe signals are saved to an HDF5 file.\n\nAlternatively, you can use data from the \n\nLISA Data Challenge.\n\n## Installations (uncomment and run)\n# !apt-get install liblapacke-dev libgsl-dev\n# !ln -s /usr/lib/x86_64-linux-gnu/libhdf5_serial_hl.so /usr/lib/x86_64-linux-gnu/libhdf5_hl.so\n# !ln -s /usr/lib/x86_64-linux-gnu/libhdf5_serial.so /usr/lib/x86_64-linux-gnu/libhdf5.so\n# !pip install fastemriwaveforms lisaanalysistools bbhx gbgpu h5py pywavelet\n\n\n\nimport numpy as np\nimport h5py\nimport warnings\nfrom typing import Tuple\nimport os\nimport scipy\nfrom scipy.signal.windows import tukey\n\nwarnings.filterwarnings(\"ignore\")\n\nS_DAY = 60 * 60 * 24  # seconds in a day\nN = 2**18\nDATA_FILE = \"data.h5\"\n\nRADLER_DATASETS = dict(\n    MBH=\"LDC1-1_MBHB_v1_1_FD_noiseless.hdf5\",\n    EMRI=\"LDC1-2_EMRI_v1_noiseless.hdf5\",\n    VGB=\"LDC1-3_VGB_v1_FD_noiseless.hdf5\",\n)\n\n\ndef generate_emri(fname=\"EMRI.h5\") -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate an EMRI frequency domain waveform.\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: (frequency array, waveform)\n    \"\"\"\n    from few.waveform import GenerateEMRIWaveform\n    from few.trajectory.inspiral import EMRIInspiral\n    from few.utils.utility import get_p_at_t\n\n    # EMRI parameters\n    Tobs = 1.0  # observation time\n    dt = 10.0  # time interval\n    eps = 0  # mode content percentage\n    M = 1e6  # central object mass\n    mu = 10.0  # secondary object mass\n    e0 = 0.6  # eccentricity\n    a = 0.1  # spin parameter (ignored for Schwarzschild)\n    x0 = 1.0  # ignored in Schwarzschild waveform\n\n    # Angles and phases (all in radians)\n    qS = np.pi / 3\n    phiS = np.pi / 3\n    qK = np.pi / 3\n    phiK = np.pi / 3\n    Phi_phi0 = np.pi / 3\n    Phi_theta0 = 0.0\n    Phi_r0 = np.pi / 3\n    dist = 1.0\n\n    # Common waveform kwargs\n    waveform_kwargs = {\"T\": Tobs, \"dt\": dt, \"eps\": eps}\n\n    # Compute the initial semi-latus rectum (p0)\n    traj_module = EMRIInspiral(func=\"SchwarzEccFlux\")\n    p0 = get_p_at_t(\n        traj_module,\n        Tobs * 0.99,\n        [M, mu, 0.0, e0, 1.0],\n        index_of_p=3,\n        index_of_a=2,\n        index_of_e=4,\n        index_of_x=5,\n        traj_kwargs={},\n        xtol=2e-12,\n        rtol=8.881784197001252e-16,\n        bounds=None,\n    )\n\n    # Injection parameters:\n    # [M, mu, a, p0, e0, x0, dist, qS, phiS, qK, phiK, Phi_phi0, Phi_theta0, Phi_r0]\n    emri_injection_params = [\n        M,\n        mu,\n        a,\n        p0,\n        e0,\n        x0,\n        dist,\n        qS,\n        phiS,\n        qK,\n        phiK,\n        Phi_phi0,\n        Phi_theta0,\n        Phi_r0,\n    ]\n\n    # Create a time-domain generator to get the correct FFT grid.\n    td_gen = GenerateEMRIWaveform(\n        \"FastSchwarzschildEccentricFlux\",\n        sum_kwargs=dict(pad_output=False, odd_len=True),\n        return_list=True,\n    )\n    h_td = td_gen(*emri_injection_params, **waveform_kwargs)[\n        0\n    ]  # get + polarization\n    h_fd = np.fft.fftshift(np.fft.fft(h_td)) * dt\n    N = len(h_td)\n    freq_all = np.fft.fftshift(np.fft.fftfreq(N, dt))\n    positive_mask = freq_all >= 0.0\n    freq = freq_all[positive_mask]\n    hf_fd = h_fd[positive_mask]  # Grab only +ve frequencies\n\n    # save EMRI data\n    with h5py.File(fname, \"a\") as f:\n        grp = f.create_group(\"EMRI\")\n        grp.create_dataset(\"freq\", data=freq)\n        grp.create_dataset(\"hf\", data=hf_fd)\n\n\ndef generate_gb(fname) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate a Galactic Binary signal.\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: (frequency array, waveform)\n    \"\"\"\n    from gbgpu.gbgpu import GBGPU\n    from lisatools.utils.constants import YRSID_SI\n\n    gb = GBGPU()\n    # Galactic Binary parameters\n    amp = 2e-23  # amplitude\n    f0 = 3e-3  # initial frequency\n    fdot = 7.538331e-18\n    fddot = 0.0\n    phi0 = 0.1  # initial phase\n    inc = 0.2  # inclination\n    psi = 0.3  # polarization angle\n    lam = 0.4  # ecliptic longitude\n    beta = 0.5  # ecliptic latitude\n\n    gb.run_wave(amp, f0, fdot, fddot, phi0, inc, psi, lam, beta, N=2**16)\n    f, hf = gb.freqs[0], gb.A[0]  # A  --> A channel\n\n    with h5py.File(fname, \"a\") as f_out:\n        grp = f_out.create_group(\"GB\")\n        grp.create_dataset(\"freq\", data=f)\n        grp.create_dataset(\"hf\", data=hf)\n\n\ndef generate_mbh(fname) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate an MBH (massive black hole) waveform.\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: (frequency array, waveform)\n    \"\"\"\n    from bbhx.waveforms.phenomhm import PhenomHMAmpPhase\n    from lisatools.utils.constants import PC_SI\n\n    wave_gen = PhenomHMAmpPhase()\n    # MBH parameters\n    m1 = 2e6\n    m2 = 7e5\n    chi1 = 0.5\n    chi2 = 0.7\n    dist = 3000 * 1e9 * PC_SI\n    phi_ref = 0.6\n    f_ref = 0.0\n    t_ref = 1e6  # seconds\n    length = 2**16\n\n    wave_gen(m1, m2, chi1, chi2, dist, phi_ref, f_ref, t_ref, length)\n\n    fd = wave_gen.amp[0, 0] * np.exp(\n        1j * -wave_gen.phase[0, 0]\n    )  # grabbing [(2,2), +pol]\n    freq = wave_gen.freqs_shaped[0, 0]\n\n    with h5py.File(fname, \"a\") as f_out:\n        grp = f_out.create_group(\"MBH\")\n        grp.create_dataset(\"freq\", data=freq)\n        grp.create_dataset(\"hf\", data=fd)\n\n\ndef load_radler_data(key, fname):\n    from pywavelet.types import TimeSeries\n\n    load_fname = f\"radler/{RADLER_DATASETS[key]}\"\n\n    with h5py.File(load_fname, \"r\") as f:\n        tdi_data = f[\"H5LISA/PreProcess/TDIdata\"][:]\n        t, x, y, z = tdi_data.T\n        ts = TimeSeries(data=x, time=t)\n\n    fd = ts.to_frequencyseries()\n    with h5py.File(fname, \"a\") as f_out:\n        grp = f_out.create_group(key)\n        grp.create_dataset(\"freq\", data=fd.freq)\n        grp.create_dataset(\"hf\", data=fd.data)\n\n\ndef main():\n    if not os.path.exists(DATA_FILE):\n        # Generate signals\n        generate_emri(DATA_FILE)\n        if not os.path.exists(\"radler\"):\n            generate_gb(DATA_FILE)\n            generate_mbh(DATA_FILE)\n        else:\n            load_radler_data(\"VGB\", DATA_FILE)\n            load_radler_data(\"MBH\", DATA_FILE)\n\n    # print keys in the data file\n    with h5py.File(DATA_FILE, \"r\") as f:\n        print(\"Available datasets in the data file:\")\n        for key in f.keys():\n            print(f\"- {key}\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n\nNext we load the data, compute the WDM transforms and plot the results.\n\nimport h5py\nimport numpy as np\n\nfrom lisatools.sensitivity import get_sensitivity\n\nfrom pywavelet.types import FrequencySeries, Wavelet, TimeSeries\nfrom dataclasses import dataclass\nfrom typing import Dict\nimport matplotlib.gridspec as gridspec\nfrom matplotlib.colors import LogNorm\nfrom matplotlib.ticker import ScalarFormatter\n\nimport matplotlib.pyplot as plt\n\n# Set the desired RC parameters\nrc_params = {\n    \"xtick.direction\": \"in\",  # Mirrored ticks (in and out)\n    \"ytick.direction\": \"in\",\n    \"xtick.top\": True,  # Show ticks on the top spine\n    \"ytick.right\": True,  # Show ticks on the right spine\n    \"xtick.major.size\": 6,  # Length of major ticks\n    \"ytick.major.size\": 6,\n    \"xtick.minor.size\": 4,  # Length of minor ticks\n    \"ytick.minor.size\": 4,\n    \"xtick.major.pad\": 4,  # Padding between tick and label\n    \"ytick.major.pad\": 4,\n    \"xtick.minor.pad\": 4,\n    \"ytick.minor.pad\": 4,\n    \"font.size\": 14,  # Overall font size\n    \"axes.labelsize\": 16,  # Font size of axis labels\n    \"axes.titlesize\": 18,  # Font size of plot title\n    \"xtick.labelsize\": 12,  # Font size of x-axis tick labels\n    \"ytick.labelsize\": 12,  # Font size of y-axis tick labels\n    \"xtick.major.width\": 2,  # Thickness of major ticks\n    \"ytick.major.width\": 2,  # Thickness of major ticks\n    \"xtick.minor.width\": 1,  # Thickness of minor ticks\n    \"ytick.minor.width\": 1,  # Thickness of minor ticks\n    \"lines.linewidth\": 3,  # Default linewidth for lines in plots\n    \"patch.linewidth\": 4,  # Default linewidth for patches (e.g., rectangles, circles)\n    \"axes.linewidth\": 2,  # Default linewidth for the axes spines\n}\n\n# Apply the RC parameters globally\nplt.rcParams.update(rc_params)\n\nCOLORS = dict(MBH=\"#17becf\", EMRI=\"#c9c9c9\", VGB=\"#d62728\")\n\n\n@dataclass\nclass PlotData:\n    freqseries: FrequencySeries\n    wavelet: Wavelet\n    label: str\n\n\ndef load_data() -> Dict[str, PlotData]:\n    \"\"\"\n    Load data from HDF5 files.\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: (frequency array, waveform)\n    \"\"\"\n    # Load the data from the HDF5 file\n    keys = [\"EMRI\", \"VGB\", \"MBH\"]\n    data = {}\n    with h5py.File(\"data.h5\", \"r\") as f:\n        for key in keys:\n            freqseries = FrequencySeries(f[key][\"hf\"][:], f[key][\"freq\"][:])\n            wdm = freqseries.to_wavelet(Nf=1024)\n            data[key] = PlotData(\n                freqseries=freqseries, wavelet=wdm, label=key.upper()\n            )\n    return data\n\n\ndef generate_plot(data: Dict[str, PlotData]):\n    # Create figure and gridspec\n    fig = plt.figure(figsize=(10, 6))\n    gs = gridspec.GridSpec(\n        2, 3, figure=fig, height_ratios=[1, 1]\n    )  # 2 rows, 3 columns\n\n    # Create subplots\n    ax0 = fig.add_subplot(gs[0, :])  # Row 1: spans all 3 columns\n    ax1 = fig.add_subplot(gs[1, 0])  # Row 2, Column 1\n    ax2 = fig.add_subplot(gs[1, 1])  # Row 2, Column 2\n    ax3 = fig.add_subplot(gs[1, 2])  # Row 2, Column 3\n    axs = [ax1, ax2, ax3]\n\n    ### Plot characteristic strain\n\n    f_fixed = np.logspace(-4, -1, 1000)\n    sensitivity = get_sensitivity(\n        f_fixed, sens_fn=\"LISASens\", return_type=\"char_strain\"\n    )\n    ax0.loglog(\n        f_fixed, sensitivity, \"k--\", label=\"LISA Sensitivity\", zorder=-5\n    )\n    ax0.set_xlim(1e-4, 1e-1)\n    ax0.set_ylim(bottom=10**-22, top=10**-18)\n    # reduce padding for xlabel\n    ax0.set_xlabel(r\"$f$ [Hz]\", labelpad=-5)\n    ax0.set_ylabel(r\"Characteristic Strain\")\n\n    # rearrange data [EMRI, MBH, GB]\n    data = {k: data[k] for k in [\"EMRI\", \"MBH\", \"VGB\"]}\n\n    for k, d in data.items():\n        f, hf = d.freqseries.freq, d.freqseries.data\n        zorder = -10 if k == \"EMRI\" else 10\n        ax0.loglog(\n            f[1:],\n            (np.abs(hf) * f)[1:],\n            label=f\"{d.label}\",\n            color=COLORS[k],\n            zorder=zorder,\n        )\n\n    ax0.legend(frameon=False)\n\n    # ### Plot WDMs (share colorbar)\n    log_norm = LogNorm(vmin=10**-31, vmax=10**-19)\n\n    for i, (k, d) in enumerate(data.items()):\n        kwgs = dict(\n            absolute=True,\n            zscale=\"log\",\n            cmap=\"inferno\",\n            ax=axs[i],\n            norm=log_norm,\n            show_gridinfo=False,\n            show_colorbar=False,\n        )\n        if i == 2:\n            kwgs[\"show_colorbar\"] = True\n        d.wavelet.plot(**kwgs)\n        axs[i].text(\n            0.05,\n            0.95,\n            d.label,\n            color=COLORS[k],\n            transform=axs[i].transAxes,\n            verticalalignment=\"top\",\n            # extra bold font\n            fontweight=\"bold\",\n        )\n        if k == \"VGB\":\n            axs[i].set_ylim(0.001, 0.008)\n        elif k == \"MBH\":\n            axs[i].set_ylim(0.0001, 0.003)\n            axs[i].set_xlim(173 * S_DAY, 340 * S_DAY)\n\n    ax1.set_ylabel(r\"$f$ [Hz]\")\n    ax2.set_ylabel(\"\")\n    ax3.set_ylabel(\"\")\n    ax1.set_ylim(top=0.02)\n\n    cbar = plt.gca().images[-1].colorbar\n\n    # cbar = ax3.collections[0].colorbar\n    cbar.set_label(r\"\")\n    cbar.ax.yaxis.label.set(rotation=0, ha=\"right\", va=\"bottom\")\n    cbar.ax.yaxis.set_tick_params(rotation=0)\n\n    # make yticks only use 2 digits, and use only 3 ticks\n    for ax in axs:\n        ax.set_xlabel(r\"$t$ [days]\")\n        ax.xaxis.set_major_locator(plt.MaxNLocator(nbins=3))\n        ax.yaxis.set_major_locator(plt.MaxNLocator(nbins=4, prune=\"both\"))\n        ax.yaxis.set_major_formatter(ScalarFormatter(useMathText=True))\n        ax.ticklabel_format(axis=\"y\", style=\"sci\", scilimits=(0, 0))\n    return fig, axs\n\n\n\ndata = load_data()\n\n\n\nfig, axs = generate_plot(data)\nplt.tight_layout()\nplt.savefig(\"example_signals.png\", dpi=300, bbox_inches=\"tight\")\n\n\n\n\n\nfig, axs = generate_plot(data)\nplt.tight_layout()\nplt.savefig(\"example_signals.pdf\", dpi=300, bbox_inches=\"tight\")\n\n","type":"content","url":"/examples/example-signals#emri-galactic-binary-and-mbh-transformation-examples","position":3},{"hierarchy":{"lvl1":"Runtime Comparisons"},"type":"lvl1","url":"/examples/runtime","position":0},{"hierarchy":{"lvl1":"Runtime Comparisons"},"content":"","type":"content","url":"/examples/runtime","position":1},{"hierarchy":{"lvl1":"Runtime Comparisons"},"type":"lvl1","url":"/examples/runtime#runtime-comparisons","position":2},{"hierarchy":{"lvl1":"Runtime Comparisons"},"content":"\n\nimport time\n\n! pip install pywavelet -q\n\n\n\nimport numpy as np\nimport jax.numpy as jnp\nimport pandas as pd\nimport jax\nimport json\nimport os\n\nfrom pywavelet.backend import cuda_available\nfrom tqdm.auto import tqdm\nfrom pywavelet.types import FrequencySeries\nfrom pywavelet.transforms.phi_computer import phitilde_vec_norm\nfrom timeit import repeat as timing_repeat\nimport matplotlib.pyplot as plt\nfrom typing import Tuple\nimport glob\n\njax.config.update(\"jax_enable_x64\", False)\nJAX_DEVICE = jax.default_backend()\nJAX_PRECISION = \"x64\" if jax.config.jax_enable_x64 else \"x32\"\n\nif cuda_available:\n    import cupy as cp\n\nmin_pow2 = 2\nmax_pow2 = 14\nNF = [2**i for i in range(min_pow2, max_pow2)]\nNREP = 5\n\n\ndef generate_freq_domain_signal(\n    ND, f0=20.0, dt=0.0125, A=2\n) -> FrequencySeries:\n    \"\"\"\n    Generates a frequency domain signal.\n\n    Parameters:\n    ND (int): Number of data points.\n    f0 (float): Frequency of the signal. Default is 20.0.\n    dt (float): Time step. Default is 0.0125.\n    A (float): Amplitude of the signal. Default is 2.\n\n    Returns:\n    FrequencySeries: The generated frequency domain signal.\n    \"\"\"\n    ts = np.arange(0, ND) * dt\n    y = A * np.sin(2 * np.pi * f0 * ts)\n    yf = FrequencySeries(y, ts)\n    return yf\n\n\ndef generate_func_args(ND: int, label=\"numpy\") -> Tuple:\n    Nf = Nt = int(np.sqrt(ND))\n    yf = generate_freq_domain_signal(ND).data\n    phif = phitilde_vec_norm(Nf, Nt, d=4.0)\n    if \"jax\" in label:\n        yf = jnp.array(yf)\n        phif = jnp.array(phif)\n    if \"cupy\" in label and cuda_available:\n        yf = cp.array(yf)\n        phif = cp.array(phif)\n    return yf, Nf, Nt, phif\n\n\ndef collect_runtime(func, func_args) -> Tuple[float, float]:\n    warm_time = 0\n    for i in range(5):\n        t0 = time.process_time()\n        func(*func_args)  # Warm up run\n        warm_time = time.process_time() - t0\n\n    if warm_time < 0.001:\n        number = 1000\n    elif warm_time < 0.1:\n        number = 10\n    else:\n        number = 1\n    # see https://stackoverflow.com/questions/48258008/n-and-r-arguments-to-ipythons-timeit-magic/59543135#59543135\n\n    times = timing_repeat(lambda: func(*func_args), number=number, repeat=NREP)\n    return np.median(times), np.std(times)\n\n\ndef collect_runtimes(func, label, NF_values) -> np.ndarray:\n    results = np.zeros((len(NF_values), 3))\n    bar = tqdm(NF_values, desc=\"Running\")\n    for i, Nf in enumerate(bar):\n        ND = Nf * Nf\n        bar.set_postfix(ND=f\"2**{int(np.log2(ND))}\")\n        func_args = generate_func_args(ND, label)\n        try:\n            _times = collect_runtime(func, func_args)\n        except Exception as e:\n            print(f\"Error processing ND={ND}: {e}\")\n            _times = (np.nan, np.nan)\n        results[i] = np.array([ND, *_times])\n\n    runtimes = pd.DataFrame(results, columns=[\"ND\", \"median\", \"std\"])\n    runtimes.to_csv(f\"runtime_{label}.csv\", index=False)\n\n    return runtimes\n\n\ndef save_jax_runtimes():\n    from pywavelet.transforms.jax.forward.from_freq import (\n        transform_wavelet_freq_helper as jax_transform,\n    )\n\n    jax_label = f\"jax_{JAX_DEVICE}_{JAX_PRECISION}\"\n    collect_runtimes(jax_transform, jax_label, NF)\n\n\ndef save_cupy_runtimes():\n    from pywavelet.transforms.cupy.forward.from_freq import (\n        transform_wavelet_freq_helper as cp_transform,\n    )\n\n    collect_runtimes(cp_transform, \"cupy\", NF)\n\n\ndef save_numpy_runtimes():\n    from pywavelet.transforms.numpy.forward.from_freq import (\n        transform_wavelet_freq_helper as np_transform,\n    )\n\n    collect_runtimes(np_transform, \"numpy\", NF)\n\n\ndef cache_all_runtimes(cache_fn: str = \"runtimes.json\"):\n    data = {}\n    for f in glob.glob(\"runtime_*.csv\"):\n        df = pd.read_csv(f)\n        label = f.split(\"runtime_\")[1].split(\".\")[0]\n        data[label] = df.to_dict(orient=\"records\")\n\n    # load any existing data\n    if os.path.exists(cache_fn):\n        with open(cache_fn, \"r\") as f:\n            existing_data = json.load(f)\n            data.update(existing_data)\n\n    # save to json\n    with open(cache_fn, \"w\") as f:\n        json.dump(data, f, indent=4)\n\n\nsave_numpy_runtimes()\nsave_jax_runtimes()\ncache_all_runtimes()\n\n\n\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport json\nimport numpy as np\nfrom typing import Tuple\n\n\nimport matplotlib.pyplot as plt\n\n# Set the desired RC parameters\nrc_params = {\n    \"xtick.direction\": \"in\",  # Mirrored ticks (in and out)\n    \"ytick.direction\": \"in\",\n    \"xtick.top\": True,  # Show ticks on the top spine\n    \"ytick.right\": True,  # Show ticks on the right spine\n    \"xtick.major.size\": 6,  # Length of major ticks\n    \"ytick.major.size\": 6,\n    \"xtick.minor.size\": 4,  # Length of minor ticks\n    \"ytick.minor.size\": 4,\n    \"xtick.major.pad\": 4,  # Padding between tick and label\n    \"ytick.major.pad\": 4,\n    \"xtick.minor.pad\": 4,\n    \"ytick.minor.pad\": 4,\n    \"font.size\": 14,  # Overall font size\n    \"axes.labelsize\": 16,  # Font size of axis labels\n    \"axes.titlesize\": 18,  # Font size of plot title\n    \"xtick.labelsize\": 12,  # Font size of x-axis tick labels\n    \"ytick.labelsize\": 12,  # Font size of y-axis tick labels\n    \"xtick.major.width\": 2,  # Thickness of major ticks\n    \"ytick.major.width\": 2,  # Thickness of major ticks\n    \"xtick.minor.width\": 1,  # Thickness of minor ticks\n    \"ytick.minor.width\": 1,  # Thickness of minor ticks\n    \"lines.linewidth\": 3,  # Default linewidth for lines in plots\n    \"patch.linewidth\": 4,  # Default linewidth for patches (e.g., rectangles, circles)\n    \"axes.linewidth\": 2,  # Default linewidth for the axes spines\n}\n\n# Apply the RC parameters globally\nplt.rcParams.update(rc_params)\n\n\nJAX_LOGO = \"https://github.com/jax-ml/jax/blob/main/images/jax_logo.png\"\nNUMPY_LOGO = \"https://github.com/numpy/numpy/blob/main/branding/logo/primary/numpylogo.png\"\nCUPY_LOGO = (\n    \"https://github.com/cupy/cupy/blob/main/docs/image/cupy_logo_1000px.png\"\n)\n\n\ndef plot_all_runtimes(cache_fn: str = \"runtimes.json\"):\n    fig, ax = plt.subplots(figsize=(4, 3.5))\n\n    with open(cache_fn, \"r\") as f:\n        data = json.load(f)\n        for label, runtimes in data.items():\n            runtimes = pd.DataFrame(runtimes)\n            _, _, line = plot(runtimes, ax=ax, label=label)\n    ax.legend(frameon=False)\n    return fig, ax\n\n\ndef plot(\n    runtimes: pd.DataFrame, ax=None, **kwgs\n) -> Tuple[plt.Figure, plt.Axes]:\n    if ax is None:\n        fig, ax = plt.subplots(figsize=(4, 3.5))\n    fig = ax.figure\n\n    runtimes = runtimes.dropna()\n    runtimes = runtimes.sort_values(by=\"ND\")\n\n    nds = runtimes[\"ND\"].values\n    times, stds = runtimes[\"median\"], runtimes[\"std\"]\n    line = ax.plot(nds, times, **kwgs)\n    kwgs[\"label\"] = None\n    ax.fill_between(\n        nds,\n        np.array(times) - np.array(stds),\n        np.array(times) + np.array(stds),\n        alpha=0.3,\n        **kwgs,\n    )\n\n    ax.set_yscale(\"log\")\n    ax.set_xscale(\"log\")\n    ax.set_xlabel(\"Number of Data Points\")\n    ax.set_ylabel(\"Runtime (s)\")\n    return fig, ax, line\n\n\nfig, ax = plot_all_runtimes()\nfig.savefig(\"runtimes.png\", bbox_inches=\"tight\")\n\n\n\nRuntime comparison figure is generated during benchmarking and is not checked into the repository.","type":"content","url":"/examples/runtime#runtime-comparisons","position":3},{"hierarchy":{"lvl1":"PyWavelet"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"PyWavelet"},"content":"PyWavelet is a Python package for transforming 1D data into the wavelet\ndomain.\n\nTo install the package, run:pip install pywavelet","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"PyWavelet","lvl2":"Acknowledging PyWavelet"},"type":"lvl2","url":"/#acknowledging-pywavelet","position":2},{"hierarchy":{"lvl1":"PyWavelet","lvl2":"Acknowledging PyWavelet"},"content":"If you use PyWavelet in your research, please acknowledge it by citing the\nfollowing works:@ARTICLE{Cornish:2020:PhRvD,\n       author = {{Cornish}, Neil J.},\n       title = \"{Time-frequency analysis of gravitational wave freqseries}\",\n       journal = {{Physical Review D}},\n       keywords = {General Relativity and Quantum Cosmology, Astrophysics - High Energy Astrophysical Phenomena},\n       year = 2020,\n       month = dec,\n       volume = {102},\n       number = {12},\n       eid = {124038},\n       pages = {124038},\n       doi = {10.1103/PhysRevD.102.124038},\n       archivePrefix = {arXiv},\n       eprint = {2009.00043},\n       primaryClass = {gr-qc},\n       adsurl = {https://ui.adsabs.harvard.edu/abs/2020PhRvD.102l4038C},\n       adsnote = {Provided by the SAO/NASA Astrophysics Coupled Data System},\n       url = {https://arxiv.org/abs/2009.00043},\n}\n\n@misc{CornishWDMTransformRepo,\n    author = {Neil Cornish},\n    url = {https://github.com/eXtremeGravityInstitute/WDM_Transform},\n    title = {WDM_Transform},\n    year = {2020},\n}\n\n@misc{MCDigmanWDMTransformRepo,\n    author = {MC Digman},\n    url = {https://github.com/XGI-MSU/WDMWaveletTransforms},\n    title = {WDMWaveletTransforms},\n    year = {2023},\n}","type":"content","url":"/#acknowledging-pywavelet","position":3}]}